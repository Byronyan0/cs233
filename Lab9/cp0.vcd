$date
	Thu Mar 22 08:51:23 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module cp0_test $end
$var wire 32 ! rd_data [31:0] $end
$var wire 1 " TakenInterrupt $end
$var wire 30 # EPC [29:0] $end
$var reg 1 $ ERET $end
$var reg 1 % MTC0 $end
$var reg 1 & TimerInterrupt $end
$var reg 1 ' clock $end
$var reg 30 ( next_pc [29:0] $end
$var reg 5 ) regnum [4:0] $end
$var reg 1 * reset $end
$var reg 32 + wr_data [31:0] $end
$scope module c0 $end
$var wire 1 $ ERET $end
$var wire 1 % MTC0 $end
$var wire 1 " TakenInterrupt $end
$var wire 1 & TimerInterrupt $end
$var wire 1 , anddown $end
$var wire 1 - andup $end
$var wire 1 ' clock $end
$var wire 1 . enableEPC $end
$var wire 30 / next_pc [29:0] $end
$var wire 1 0 notup $end
$var wire 5 1 regnum [4:0] $end
$var wire 1 * reset $end
$var wire 1 2 resetEx $end
$var wire 32 3 wr_data [31:0] $end
$var wire 32 4 userStatus [31:0] $end
$var wire 32 5 statusReg [31:0] $end
$var wire 32 6 rd_data [31:0] $end
$var wire 1 7 exceptionLevel $end
$var wire 32 8 decode [31:0] $end
$var wire 32 9 causeReg [31:0] $end
$var wire 30 : EPC [29:0] $end
$var wire 30 ; D [29:0] $end
$scope module EPCRegister $end
$var wire 1 ' clk $end
$var wire 1 . enable $end
$var wire 1 * reset $end
$var wire 30 < d [29:0] $end
$var reg 30 = q [29:0] $end
$upscope $end
$scope module enable $end
$var wire 1 % enable $end
$var wire 5 > in [4:0] $end
$var wire 32 ? out [31:0] $end
$upscope $end
$scope module exceptionLevel0 $end
$var wire 1 ' clk $end
$var wire 1 @ d $end
$var wire 1 " enable $end
$var wire 1 2 reset $end
$var reg 1 7 q $end
$upscope $end
$scope module mux0 $end
$var wire 32 A A [31:0] $end
$var wire 32 B B [31:0] $end
$var wire 32 C C [31:0] $end
$var wire 2 D sel [1:0] $end
$var wire 32 E wAB [31:0] $end
$var wire 32 F out [31:0] $end
$scope module mAB $end
$var wire 32 G A [31:0] $end
$var wire 32 H B [31:0] $end
$var wire 32 I out [31:0] $end
$var wire 1 J sel $end
$var wire 32 K temp1 [31:0] $end
$var wire 32 L temp2 [31:0] $end
$upscope $end
$scope module mfinal $end
$var wire 32 M A [31:0] $end
$var wire 32 N B [31:0] $end
$var wire 32 O out [31:0] $end
$var wire 1 P sel $end
$var wire 32 Q temp1 [31:0] $end
$var wire 32 R temp2 [31:0] $end
$upscope $end
$upscope $end
$scope module userStatus0 $end
$var wire 1 ' clk $end
$var wire 32 S d [31:0] $end
$var wire 1 T enable $end
$var wire 1 * reset $end
$var reg 32 U q [31:0] $end
$upscope $end
$scope module wrdataOrNextPC $end
$var wire 30 V A [29:0] $end
$var wire 30 W B [29:0] $end
$var wire 30 X out [29:0] $end
$var wire 1 " sel $end
$var wire 30 Y temp1 [29:0] $end
$var wire 30 Z temp2 [29:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 Z
b0 Y
b0 X
b0 W
b0 V
bx U
0T
b0 S
b0 R
b0xxxxxxxx000000xx Q
0P
b0xxxxxxxx000000xx O
bx00 N
b0xxxxxxxx000000xx M
b0 L
b0xxxxxxxx000000xx K
0J
b0xxxxxxxx000000xx I
b0 H
b0xxxxxxxx000000xx G
b0xxxxxxxx000000xx F
b0xxxxxxxx000000xx E
b0 D
bx00 C
b0 B
b0xxxxxxxx000000xx A
1@
b0 ?
b0 >
bx =
b0 <
b0 ;
bx :
b0 9
b0 8
x7
b0xxxxxxxx000000xx 6
b0xxxxxxxx000000xx 5
bx 4
b0 3
12
b0 1
x0
b0 /
0.
0-
x,
b0 +
1*
b0 )
b0 (
0'
0&
0%
0$
bx #
0"
b0xxxxxxxx000000xx !
$end
#5
b0 !
b0 6
b0 F
b0 O
0,
b0 Q
10
b0 E
b0 I
b0 M
b0 K
b0 4
b0 U
b0 5
b0 A
b0 G
07
b0 C
b0 N
b0 #
b0 :
b0 =
1'
#10
b111111111111111111111111111111 ;
b111111111111111111111111111111 <
b111111111111111111111111111111 X
b111111111111111111111111111111 Y
1T
b111111111111111111111111111111 V
b1000000000000 8
b1000000000000 ?
02
0'
b11111111111111111111111111111111 +
b11111111111111111111111111111111 3
b11111111111111111111111111111111 S
b1100 )
b1100 1
b1100 >
1%
0*
#15
b1111111100000001 !
b1111111100000001 6
b1111111100000001 F
b1111111100000001 O
b1111111100000001 Q
1,
b1111111100000001 E
b1111111100000001 I
b1111111100000001 M
b1111111100000001 K
b1111111100000001 5
b1111111100000001 A
b1111111100000001 G
b11111111111111111111111111111111 4
b11111111111111111111111111111111 U
1'
#20
0T
b0 8
b0 ?
0'
0%
#25
1'
#30
b100000000000000000001 ;
b100000000000000000001 <
b100000000000000000001 X
b0 Y
b100000000000000000001 Z
1.
1"
1-
0'
b100000000000000000001 (
b100000000000000000001 /
b100000000000000000001 W
b1000000000000000 9
b1000000000000000 B
b1000000000000000 H
1&
#35
b111111111111111111111111111111 ;
b111111111111111111111111111111 <
b111111111111111111111111111111 X
b111111111111111111111111111111 Y
b0 Z
0.
0"
b1111111100000011 !
b1111111100000011 6
b1111111100000011 F
b1111111100000011 O
0,
b1111111100000011 Q
00
b1111111100000011 E
b1111111100000011 I
b1111111100000011 M
b1111111100000011 K
b10000000000000000000100 C
b10000000000000000000100 N
b100000000000000000001 #
b100000000000000000001 :
b100000000000000000001 =
b1111111100000011 5
b1111111100000011 A
b1111111100000011 G
17
1'
#40
0'
b100000000000000000010 (
b100000000000000000010 /
b100000000000000000010 W
#45
1'
#50
b10000000000000000000100 !
b10000000000000000000100 6
b10000000000000000000100 F
b10000000000000000000100 O
b0 Q
b10000000000000000000100 R
1P
b10 D
0'
b1110 )
b1110 1
b1110 >
#55
1'
#60
b1000000000000000 E
b1000000000000000 I
b1000000000000000 M
b1000000000000000 !
b1000000000000000 6
b1000000000000000 F
b1000000000000000 O
b0 K
b1000000000000000 L
b1000000000000000 Q
b0 R
1J
0P
b1 D
0'
b1101 )
b1101 1
b1101 >
#65
1'
#70
b0 !
b0 6
b0 F
b0 O
b0 Q
0-
b0 E
b0 I
b0 M
12
b0 L
0'
1$
b0 9
b0 B
b0 H
0&
#75
1,
10
b1111111100000001 5
b1111111100000001 A
b1111111100000001 G
07
1'
#80
b1111111100000001 !
b1111111100000001 6
b1111111100000001 F
b1111111100000001 O
b1111111100000001 Q
b1111111100000001 E
b1111111100000001 I
b1111111100000001 M
b1111111100000001 K
0J
b0 D
0'
b1100 )
b1100 1
b1100 >
#85
1'
#90
b0 !
b0 6
b0 F
b0 O
b0 Q
b0 E
b0 I
b0 M
b0 K
1J
b1 D
0'
b1101 )
b1101 1
b1101 >
#95
1'
#100
0'
